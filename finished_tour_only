from PIL import Image, ImageDraw, ImageFont
import pulp
import math
import numpy as np
#from graph import Graph
import collections
import random


if __name__ == "__main__":
    def dist(p1, p2):  # takes tuple
        distance = math.sqrt(((p1[0] - p2[0]) ** 2) + ((p1[1] - p2[1]) ** 2))
        return distance

    w, h = 1024, 512
    data = np.zeros((h, w, 3), dtype=np.uint8)
    for i in range(0, 500):
        for j in range(0, 1024):
            data[i, j] = [100,100,100]

    img = Image.fromarray(data, 'RGB')
    draw = ImageDraw.Draw(img)

    #Generates coordinates
    r = random.seed()
    num_r = random.randint(40, 50)
    r_coord = []

    for i in range(num_r):
        x = random.randint(10, 1000)
        y = random.randint(10, 500)
        r_coord.append((x,y))

    #this is basic graph
    N = num_r
    coord = []
    #filepath = "C:/Users/domed/Desktop/network-art/tsplib/test.txt"

    ##########################################
    # These are coordinates in test.txt      #
    # 0 72 131                               #
    # 1 125 100                              #
    # 2 125 162                              #
    # 3 425 100                              #
    # 4 372 131                              #
    ##########################################
    """
    with open(filepath) as fp:
        for cnt, line in enumerate(fp):
            s = line.split()
            idx, x, y = s
            coord.append((int(x),int(y)))
            # print("Line {}: {}".format(cnt, line))
            N+=1
    """
    for ss in r_coord:
        coord.append(ss)
    G = {}
    for i in range(N):
        G[i] = (coord[i][0], coord[i][1])

    ################################################################################
    #                                                                              #
    #   THIS IS THE SUBTOUR, cutting group on the left from the right              #
    #   -draws the moats around the control zone                                   #
    ################################################################################


    ################################################################################
    #                                                                              #
    #   THIS IS THE MAIN TOUR, creating the control zones                          #
    #                                                                              #
    ################################################################################

    main_tour = pulp.LpProblem("My LP Problem", pulp.LpMaximize)
    radii = {}
    for i in range(N):
        radii["r_" + str(i)] = pulp.LpVariable("r_" + str(i), lowBound=0, cat='Continuous')

    # Objective function
    main_tour += pulp.lpSum(2*radii["r_" + str(i)] for i in range(N)), "Z"

    # Constraints
    for i in range(N):
        for j in range(i + 1, N):
            main_tour += radii["r_" + str(i)] + radii["r_" + str(j)] <= dist(G[i],
                                                                                 G[j])
    main_tour.solve()

    # Stores the radii in a dict
    new_radii = {}
    for variable in main_tour.variables():
        new_radii[variable.name] = variable.varValue

    # Draws the control zones

    font = ImageFont.truetype("/tsplib/Arial.ttf", 12)

    #System > Library > Fonts C:/Windows/Fonts/arial.ttf
    for idx, v in enumerate(G):
        x, y = G[v]
        temp = new_radii["r_" + str(idx)]
        draw.ellipse([x - temp, y - temp, x + temp, y + temp], fill=(232, 217, 86))
        draw.ellipse([x - 2, y - 2, x + 2, y + 2], fill=(0, 0, 0))

    ################################################################################
    #   This creates the route, using int LP, denoted by the black lines           #
    ################################################################################
    ################################################################################
    ################################################################################
    ################################################################################
    ################################################################################

    primal = pulp.LpProblem("My LP Problem", pulp.LpMinimize)
    X = {}
    dist_xy = {}

    # Gets the distance (i,j)
    for i in range(N):
        for j in range(i + 1, N):
            dist_xy[(i, j)] = dist(coord[i], coord[j])

    # Sets the variables in dict X, either 1 or 0; tells you whether or not you take the path (i,j)
    for i in range(N):
        for j in range(i + 1, N):
            X[str(i) + "_" + str(j)] = pulp.LpVariable(str(i) + "_" + str(j), lowBound=0, cat='Binary')

    # Objective function:
    primal += pulp.lpSum(X[str(i)+"_"+str(j)] * dist_xy[(i, j)] for i in range(N) for j in range(i+1, N)), "Z"

    # Constraints
    # Creating a temp Object so that it solves it in one line

    for i in range(N):
        temp = pulp.LpAffineExpression()
        for j in range(N):
            if i != j:
                if i < j:
                    temp += pulp.lpSum(X[str(i) + "_" + str(j)])
                else:
                    temp += pulp.lpSum(X[str(j) + "_" + str(i)])
        primal += temp == 2

    primal.solve()
    X_ = []
    X_.append({})
    for variable in primal.variables():
        X[str(variable.name)] = int(variable.varValue)
        X_[0][str(variable.name)] = int(variable.varValue)

    # Connects the path for the final tour
    for path in X:
        if X[path]:
            xs = path.split("_")
            x_1, y_1 = G[int(xs[0])]
            x_2, y_2 = G[int(xs[1])]
            #draw.line([x_1, y_1, x_2, y_2], fill=(0, 0, 0), width=1)

    for idx, v in enumerate(G):
        x, y = G[v]
        draw.ellipse([x+2 , y+2, x + 17, y + 17], fill=(255, 255, 255))
        draw.text((x+5, y+2), str(idx), (0, 0, 0), font=font)




    ################################################################################
    #         DFS to find subtours S(i...N)                                        #
    ################################################################################

    # First need to create a graph
    graph = {}
    S_master = []
    for edge in X:
        if X[edge]:
            xs = edge.split("_")
            start = int(xs[0])
            end = int(xs[1])
            graph[start] = graph.get(start, []) + [end]
            graph[end] = graph.get(end, []) + [start]

    print(graph)
    S_s = [] #this is dict of all subgroups
    visited = set()
    for node in graph:
        if node not in visited:
            stack = []
            stack.append(node)
            print("s: ", stack)
            res = []
            while stack:
                vtx = stack.pop()
                if vtx not in visited:
                    res.append(vtx)
                    visited.add(vtx)
                    if vtx in graph:
                        for next in graph[vtx]:
                            if next not in visited:
                                stack.append(next)
            S_s.append(res)
    S_master.append(S_s)
    print("1st S_master: ",S_master )
    #print("S_s: ", len(S_s), S_s)
    #print(primal)
    ################################################################################
    #         for S_i in S_s
    #           add constraint: Σ (x_ij) >= 2
    #                              i ∈ S_i
    #                              j ∉ S_i
    ################################################################################
    ################################################################################
    ################################################################################
    ################################################################################
    ################################################################################
    ################################################################################
    #this will be a loop!!!
    # Gets the distance (i,j)

    def create_X(count):
        X_.append({})
        for i in range(N):
            for j in range(i + 1, N):
                X_[count][str(i) + "_" + str(j)] = pulp.LpVariable(str(i) + "_" + str(j), lowBound=0, cat='Binary')
        return X_

    #call this at the end of the while loop...
    def create_S_x(count):
        graph = {}
        S_x = []
        for edge in X_[count]:
            if X_[count][edge]:
                xs = edge.split("_")
                start = int(xs[0])
                end = int(xs[1])
                graph[start] = graph.get(start, []) + [end]
                graph[end] = graph.get(end, []) + [start]

        visited = set()
        for node in graph:
            if node not in visited:
                stack = []
                stack.append(node)
                res = []
                while stack:
                    vtx = stack.pop()
                    if vtx not in visited:
                        res.append(vtx)
                        visited.add(vtx)
                        if vtx in graph:
                            for next in graph[vtx]:
                                if next not in visited:
                                    stack.append(next)
                S_x.append(res)

        return S_x

    def add_to_S_master(S_x):
        S_master.append(S_x)
        return S_master

     #adds the new constraints in loop

    def add_to_primal(count, S_master): #takes the master
        for i in range(N):
            temp = pulp.LpAffineExpression()
            for j in range(N):
                if i != j:
                    if i < j:
                        temp += pulp.lpSum(X_[count][str(i) + "_" + str(j)])
                    else:
                        temp += pulp.lpSum(X_[count][str(j) + "_" + str(i)])
            primal_[count] += temp == 2

        for S_s in S_master:
            for idx, S_i in enumerate(S_s):
                temp = pulp.LpAffineExpression()
                for i in S_i:
                    for S_not_including_i in S_s:
                        if S_s[idx] != S_not_including_i:
                            for j in S_not_including_i:
                                if i != j:
                                    if i < j:
                                        temp += pulp.lpSum(X_[count][str(i) + "_" + str(j)])
                                    else:
                                        temp += pulp.lpSum(X_[count][str(j) + "_" + str(i)])
                primal_[count] += temp >= 2

    dist_xy = {}
    for i in range(N):
        for j in range(i + 1, N):
            dist_xy[(i, j)] = dist(coord[i], coord[j])

    primal_ = []
    primal_.append(pulp.LpProblem("this is a holder", pulp.LpMinimize))

    finished = False
    count = 1

    # print("BEFORE")
    # for variable in primal_2.variables():
    #    print("{} = {}".format(variable.name, variable.varValue))
    # print("BEFORE")

    print("first_S_s: ", S_s)

    lol = 0

    while len(S_s) > 1:
        print(count)
        primal_cur = pulp.LpProblem("THIS IS NEW", pulp.LpMinimize)
        primal_.append(primal_cur)

        # Objective function:
        create_X(count)
        primal_[count] += pulp.lpSum(X_[count][str(i)+"_"+str(j)] * dist_xy[(i, j)] for i in range(N) for j in range(i+1, N)), "Z"
        print("OBJECTIVE: ", primal_[count].objective)
                #S_s = create_S_x(count)
        # Constraints
        #add_to_S_master(S_s)
        add_to_primal(count, S_master)

        primal_[count].solve()

        # Sets the variables in dict X_2, either 1 or 0; tells you whether or not you take the path (i,j)
        for variable in primal_[count].variables():
            X_[count][str(variable.name)] = int(variable.varValue)

        S_s = create_S_x(count)
        print("new_S_s: ", S_s)
        add_to_S_master(S_s)
        print("S_master: ", S_master)

        # Gives you the final tour when we actually draw

        if len(S_s) == 1:
            ans = {}
            for variable in primal_[-1].variables():
                ans[str(variable.name)] = int(variable.varValue)
            lol += 50
            for path in ans:
                if ans[path]:
                    xs = path.split("_")
                    x_1, y_1 = G[int(xs[0])]
                    x_2, y_2 = G[int(xs[1])]
                    draw.line([x_1, y_1, x_2, y_2], fill=(lol, lol, lol), width=2)
            #print(primal_[count].objective)

        count += 1


    ######################################
    ######################################
    # Connects the path for the final tour
    #print(ans)


    #for variable in primal_[-1].variables():
     #   print("{} = {}".format(variable.name, variable.varValue))

    img.save('my.png')
    img.show()

    #issue is that now lines sometimes overlaps...maybe just do the constraints of the  S_master[-1]

    """
            ........
            all flights in and out of the city
            #the dual to the primal:
            maximize the size of the circles subject to the circles odont intersect each there
            ...look for the symmetries in the functions
            all those constraints become dual variables for the cities
    """
